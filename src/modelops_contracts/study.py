"""Study types for simulation experiments.

This module defines types for representing experimental designs
without execution details (no bundle references). These types
are used by sampling algorithms to generate parameter sweeps.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import hashlib
import uuid

from .types import UniqueParameterSet, make_param_id
from .simulation import SimTask
from .jobs import SimJob


@dataclass(frozen=True)
class ParameterSetEntry:
    """A parameter set with optional explicit seed.

    When seed is None, n_replicates tasks will be generated with
    derived seeds. When seed is specified, exactly one task is
    created with that seed.

    Attributes:
        params: Parameter dictionary
        seed: Optional explicit seed (None = generate from n_replicates)
    """
    params: Dict[str, Any]
    seed: Optional[int] = None

    def __post_init__(self):
        if self.seed is not None:
            if not isinstance(self.seed, int) or not (0 <= self.seed <= 2**64 - 1):
                raise ValueError(f"seed must be int in uint64 range, got {self.seed}")


@dataclass(frozen=True)
class SimulationStudy:
    """Abstract simulation study without execution details.

    This represents the experimental design - what to run and
    with which parameters, but not how (no bundle reference).
    Generated by sampling algorithms, then bound to a bundle
    at submission time.

    Attributes:
        model: Module path to simulation class (e.g., "models.seir")
        scenario: Scenario name (e.g., "baseline")
        parameter_sets: List of ParameterSetEntry objects (params + optional seed)
        sampling_method: How parameters were generated ("sobol", "grid", "manual")
        n_replicates: Number of replicates per parameter set (used when entry.seed is None)
        outputs: Specific outputs to extract (None = all)
        metadata: Additional study metadata
    """
    model: str
    scenario: str
    parameter_sets: List[ParameterSetEntry]
    sampling_method: str
    n_replicates: int = 1
    outputs: Optional[List[str]] = None
    targets: Optional[List[str]] = None  # Target entrypoints for loss computation
    metadata: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SimulationStudy":
        """Parse JSON with backwards compatibility.

        Supports two formats:
        - Old format: parameter_sets is List[Dict] (plain param dicts)
        - New format: parameter_sets is List[{"params": {...}, "seed": int}]

        Args:
            data: Dictionary parsed from JSON

        Returns:
            SimulationStudy instance
        """
        entries = []
        for item in data.get("parameter_sets", []):
            if isinstance(item, dict) and "params" in item:
                # New format: {"params": {...}, "seed": 52}
                entries.append(ParameterSetEntry(
                    params=item["params"],
                    seed=item.get("seed")
                ))
            else:
                # Old format: {"beta": 0.08} â†’ wrap as ParameterSetEntry
                entries.append(ParameterSetEntry(params=item, seed=None))

        return cls(
            model=data["model"],
            scenario=data["scenario"],
            parameter_sets=entries,
            sampling_method=data.get("sampling_method", "manual"),
            n_replicates=data.get("n_replicates", 1),
            outputs=data.get("outputs"),
            targets=data.get("targets"),
            metadata=data.get("metadata", {}),
        )

    def to_simjob(self, bundle_ref: str, job_id: Optional[str] = None) -> SimJob:
        """Bind this study to a bundle to create executable SimJob.

        This is the key transformation that happens at submission time,
        converting an abstract study into a concrete job.

        Args:
            bundle_ref: Bundle reference (must be sha256:64-hex-chars)
            job_id: Optional job ID, auto-generated if not provided

        Returns:
            SimJob ready for execution

        Raises:
            ValueError: If bundle_ref format is invalid
        """
        # Validate bundle_ref format using same logic as Job and SimTask
        from .simulation import SimTask
        if not SimTask._is_valid_digest(bundle_ref):
            raise ValueError(
                f"bundle_ref must be sha256:64-hex-chars or repository@sha256:64-hex-chars, got: {bundle_ref}"
            )

        # Create tasks for all parameter sets and replicates
        tasks = []
        for entry in self.parameter_sets:
            if entry.seed is not None:
                # EXPLICIT: Create 1 task with specified seed
                task = SimTask.from_components(
                    import_path=self.model,
                    scenario=self.scenario,
                    bundle_ref=bundle_ref,
                    params=entry.params,
                    seed=entry.seed,
                    outputs=self.outputs
                )
                tasks.append(task)
            else:
                # AUTO: Generate n_replicates tasks with derived seeds
                param_id = make_param_id(entry.params)
                for replicate_idx in range(self.n_replicates):
                    task = SimTask.from_components(
                        import_path=self.model,
                        scenario=self.scenario,
                        bundle_ref=bundle_ref,
                        params=entry.params,
                        seed=self._generate_seed(param_id, replicate_idx),
                        outputs=self.outputs
                    )
                    tasks.append(task)

        # Create job directly with tasks (no batch wrapper)
        if not job_id:
            job_id = f"job-{uuid.uuid4().hex[:8]}"

        # Store study metadata in job
        job_metadata = {
            "sampling_method": self.sampling_method,
            "n_parameter_sets": len(self.parameter_sets),
            "n_replicates": self.n_replicates,
            "model": self.model,
            "scenario": self.scenario,
            **self.metadata
        }

        # Create TargetSpec if targets are specified
        from .jobs import TargetSpec
        target_spec = None
        if self.targets:
            # Extract target metadata if present
            target_ids = self.metadata.get("target_ids")
            target_set = self.metadata.get("target_set")

            target_spec = TargetSpec(
                data={
                    "target_entrypoints": self.targets,
                    "target_ids": target_ids,
                    "target_set": target_set,
                },
                loss_function="default",  # Can be customized later
                metadata={
                    "targets": self.targets,
                    "target_ids": target_ids,
                    "target_set": target_set,
                }
            )

        return SimJob(
            job_id=job_id,
            tasks=tasks,  # Direct tasks list, no batch!
            bundle_ref=bundle_ref,
            metadata=job_metadata,
            target_spec=target_spec
        )

    def _generate_seed(self, param_id: str, replicate_idx: int) -> int:
        """Generate deterministic seed from param_id and replicate index.

        Args:
            param_id: Parameter set identifier
            replicate_idx: Replicate index (0-based)

        Returns:
            Seed value in uint32 range for reproducibility
        """
        content = f"{param_id}:{replicate_idx}"
        hash_bytes = hashlib.blake2b(content.encode(), digest_size=8).digest()
        # Use modulo to ensure seed fits in uint32 range
        return int.from_bytes(hash_bytes, 'big') % (2**32)

    def parameter_count(self) -> int:
        """Get number of unique parameter sets."""
        return len(self.parameter_sets)

    def total_simulation_count(self) -> int:
        """Get total number of simulations.

        For entries with explicit seeds: 1 task per entry.
        For entries without seeds: n_replicates tasks per entry.
        """
        count = 0
        for entry in self.parameter_sets:
            if entry.seed is not None:
                count += 1
            else:
                count += self.n_replicates
        return count

    def with_targets(
        self,
        targets: List[str],
        target_ids: List[str] | None = None,
        target_set: str | None = None,
    ) -> "SimulationStudy":
        """Return a new SimulationStudy with updated targets and metadata.

        This is an immutable update that preserves all other fields while
        updating the targets and related metadata.

        Args:
            targets: List of target entrypoints
            target_ids: Optional list of target IDs for tracking
            target_set: Optional target set name for reporting

        Returns:
            New SimulationStudy instance with updated targets
        """
        updated_metadata = {**self.metadata}
        if target_ids is not None:
            updated_metadata["target_ids"] = target_ids
        if target_set is not None:
            updated_metadata["target_set"] = target_set

        return SimulationStudy(
            model=self.model,
            scenario=self.scenario,
            parameter_sets=self.parameter_sets,
            sampling_method=self.sampling_method,
            n_replicates=self.n_replicates,
            outputs=self.outputs,
            targets=targets,
            metadata=updated_metadata,
        )


@dataclass(frozen=True)
class CalibrationSpec:
    """Specification for a calibration study.

    Defines the configuration for an adaptive parameter search
    without execution details. Converted to CalibrationJob at
    submission time.
    """
    model: str
    scenario: str
    algorithm: str  # "optuna", "abc-smc"
    target_data: Dict[str, Any]
    max_iterations: int
    convergence_criteria: Dict[str, float] = field(default_factory=dict)
    algorithm_config: Dict[str, Any] = field(default_factory=dict)
    outputs: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


__all__ = [
    "ParameterSetEntry",
    "SimulationStudy",
    "CalibrationSpec",
]